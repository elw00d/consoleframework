Как работает подсистема, управляющая фокусом элементов управления.

Задача управления фокусом элементов актуальна только для клавиатурного ввода, поскольку события мыши
маршрутизируются в соответствии с z-order контролов, и фокус элементов при обработке событий мыши
не учитывается. Наоборот даже, как правило, события мыши приводят к изменению фокусного элемента
(эта логика выполняется в WindowsHost.Window_OnPreviewMouseDown).

Устроено все следующим образом. 

В каждом контроле есть свойства HasFocus и Focusable. Контролы с Focusable = True могут принимать клавиатурный
ввод (то есть быть фокусными элементами). По умолчанию это свойство инициализируется значением False. Поэтому
если ваш кастомный контрол поддерживает установку фокуса на нём, то в конструкторе вы должны выставить это
свойство в True. Элемент управления, который в данный момент принимает клавиатурный ввод, имеет HasFocus = true.
Таких контролов не может быть более 1 в любой момент жизни приложения (то есть по иерархии HasFocus не
распространяется, только один контрол имеет HasFocus = True, его родительские элементы - нет). Чтобы контрол
получил фокус ввода, нужно чтобы либо кто-то вызвал FocusManager.SetFocus() явно, либо чтобы фокус перешёл от
другого контрола в текущем Focus Scope (например, если пользователь нажал Tab в окне, в котором несколько
Focusable контролов). Третий путь получения фокуса - логика для "активизируемых" контролов (таких как Window),
- описана чуть ниже. Focus Scope - это заданный родительский элемент управления, в рамках которого рекурсивно
ищутся дочерние Focusable элементы в порядке их Tab-Order (Window, Panels). Фокус всегда существует только 
в контексте некоторого Focus Scope. В роли Focus Scope могут выступать абсолютно любые контролы
(даже не имеющие дочерних, с оговоркой, что это бессмысленно). Focus Scope нужен для того, чтобы FocusManager
мог определить, какой элемент будет следующим (предыдущим) при перемещении фокуса. Можно явно вызвать
SetFocus(scope, control) для указания и фокусируемого контрола, и Focus Scope, в рамках которого будет
работать фокус. Но обычно это не требуется, поскольку есть набор умолчаний и пара дополнительных свойств,
которые позволяют не задавать Focus Scope явно в повседневных ситуациях.

У каждого контрола, который может выступать в роли Focus Scope, будет соответствующее булево проперти,
показывающее, будет ли он выступать в роли Focus Scope или нет - IsFocusScope.
Его можно задать при конструировании объекта, таким образом определив, к какому из парентов по умолчанию
будет направлено Focus Scope при вызове SetFocus(control). Например, если в окне лежит панель, а в панели -
набор Focusable элементов, то установив значение этого свойства для панели в True (в отличие от дефолтного False),
мы сможем сузить Focus Scope, который будет задан при вызове SetFocus на одном из Focusable элементов,
лежащих внутри панели. Дефолтные значения будут заданы исходя из соображений частоты использования того или
иного случая. Например, для Window значение по умолчанию будет True, поскольку как правило Window является
Focus Scope для всех дочерних контролов. По этой же причине у всех панелей значение по умолчанию будет False,
чтобы не забирать Focus Scope у окна.

Как работает FocusScope. Контролы, являющиеся FocusScope, получают фокус ввода вызовом
FocusManager.SetFocusScope(). Этот метод определяет все конечные дочерние Focusable-контролы и
передаёт фокус на первый из них (по TabOrder). Родительские контролы отбрасываются (даже Focusable).
Есть одно исключение из этого правила - если FocusScope = true и Focusable = true, а
дочерних элементов у контрола нет (пустое Focusable-окно), то фокус-таки будет передан этому окну.
Механизм, отбрасывающий промежуточных родителей, был избран для того, чтобы контролы, занимающиеся
размещением элементов (т.е. имеющие детей), не могли быть Focusable, так как это приводит к более сложной
с точки зрения логики задачи распределения клавиатурного ввода - становится непонятно, как перемещать
фокус с родительского Focusable-элемента на дочерние и наоборот. Проще сделать текущее поведение, а уж
при необходимости более сложных случаев написать специальный код переназначения фокуса вручную.

Второе. У некоторых контролов, которые поддерживают абстракцию "активизации" на экране (например, Window или
контекстное меню) должна быть возможность задать ссылку на дочерний элемент, являющийся фокусным по умолчанию
(что-то типа Attached Property). На него будет передаваться фокус при активизации контрола простым вызовом
SetFocus(control) - это будет делать сам активизируемый контрол.

Напоследок рассмотрим маршрутизируемые события, связанные с подсистемой фокуса. Если при смене фокуса
всё ок (контрол вместе
с родителями является Focusable, Visible) то посылается пара Preview-событий PreviewLostKeyboardFocus и
PreviewGotKeyboardFocus. Если при обработке этих routed events Handled будет установлен в true, то операция
SetFocus отменяется, и состояние фокуса возвращается к исходному. Если же отменять операцию не нужно,
FocusedElement будет изменен и будут посланы 2 события LostKeyboardFocus и GotKeyboardFocus.